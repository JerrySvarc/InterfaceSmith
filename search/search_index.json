{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"InterfaceSmith overview","text":"<p>InterfaceSmith is a prototype programming system providing a data-driven approach as a main technique to creating web application's UI elements using a low-code programming interface.</p>"},{"location":"#motivation","title":"Motivation","text":"<p>InterfaceSmith explores a method of creating web applications with a system which aims to guide the programmer during the creation process and aims to provide capabilities that make this process faster and without the need to write large amounts of boilerplate code. We will explain the differences between the standard way of creating web applications using text based code tools compared to our prototype system.</p>"},{"location":"#standard-workflow-today","title":"Standard workflow today","text":"<p>Imagine you aquire some JSON data from a public API and you wish to create an application which displays some of this data, and you also want to add custom functionality for the elements. The standard method would be to create an empty project in your favourite programming language, analyze the data and then create the UI elements by hand, making sure that each element properly displays the corresponding data. Then you would also change the styling of the elements using either pure CSS or a library such as Tailwind. Finally, you would add custom behaviour to react to user events, such as clicking a button or clicking on a dropdown menu.</p>"},{"location":"#workflow-using-interfacesmith","title":"Workflow using InterfaceSmith","text":"<p>Imagine you have the same data as in the previous section. You upload this data to the InterfaceSmith system, which presents you with a view of the uploaded data. It also presents you the option to create UI elements based on the data you uploaded. You pick and choose which data to use by incrementally creating the UI elements and modify these elements using the context menus which allow you to change the tag, attributes, and handlers of the element. You can also style the application using Tailwind and immedeately see the preview of the element after each change. Then you can define new Elm-style messages and define how the data should change when the message occurs, which in turn changes the application's state and the state of the UI elements.</p>"},{"location":"#installation","title":"Installation","text":"<p>To install the production version, use the provided pre-built docker image and follow the instructions in the getting-started tutorial.</p>"},{"location":"getting-started/","title":"Getting started","text":""},{"location":"getting-started/#installation","title":"Installation","text":"<p>To use the InterfaceSmith programming system, we provide two main ways of installing and running it:</p> <ol> <li>Using the provided pre-build docker image</li> <li>Building the docker image using the provided Dockerfile</li> </ol> <p>The first option is much faster, as building the image from the Dockerfile involves downloading various technologies and then compiling the entire application and the Docker image, which can take a large amount of time to complete, depending on your internet connection speed and your system's capabilities.</p>"},{"location":"getting-started/#prerequisites","title":"Prerequisites","text":"<ul> <li>Docker installed and running</li> </ul>"},{"location":"getting-started/#running-the-pre-built-image","title":"Running the pre-built image","text":"<p>Running the pre-build docker image is the preferred way to run the InterfaceSmith programming system. To start the container, do the following sequence of steps:</p> <ol> <li>Load the provided image:</li> </ol> <pre><code>docker load &lt; interfacesmith.tar\n</code></pre> <ol> <li>Run the loaded container:</li> </ol> <pre><code>docker run -p 8080:8080 -p 8082:8082 interfacesmith\n</code></pre>"},{"location":"getting-started/#building-the-dockerfile-and-running-the-app","title":"Building the Dockerfile and running the app","text":"<ol> <li>Clone the repository:</li> </ol> <pre><code>git clone https://github.com/JerrySvarc/InterfaceSmith.git\ncd InterfaceSmith\n</code></pre> <ol> <li>Build the Docker image:</li> </ol> <pre><code>docker build -t interfacesmith .\n</code></pre> <ol> <li>Run the newly built container:</li> </ol> <pre><code>docker run -p 8080:8080 -p 8082:8082 interfacesmith\n</code></pre>"},{"location":"getting-started/#endpoints","title":"Endpoints","text":"<p>When the container is running the following applications are available:</p> <ul> <li>Main editor is available on: <code>http://localhost:8080</code></li> <li>This documentation is available on: <code>http://localhost:8082</code></li> </ul>"},{"location":"getting-started/#user-interface","title":"User interface","text":"<p> Figure: Main editor interface showing the page management panel on the left and workspace on the right</p> <p>After you open the Editor, you will be presented with the application's UI we can see above. It consists of a collapsable panel on the left, which provides view of the created pages. By double clicking on the page tab, the name of the page can be changed. The page can also be deleted by clicking on the thrash bin icon on the tab. New page can be created by clicking the 'New page' button.</p> <p>On the right at the top, we can see a panel with several buttons. Under the panel, we can see a movable canvas containing draggable elements, each providing different modification functionality.</p> <p>The top left element is a ModelViewElement, which shows the uploaded JSON data. Each field can also be collapsed.</p> <p>Under the ModelViewElement, we can se the element to create, modify and delete custom functions, alongside the editor window it provides to modify the JavaScript code.</p> <p>To the right, we can see the main ViewElement, which provides the main UI creation and modification functionality. It is resizible, and also serves as a preview window for the running preview of the created application.</p> <p>To the right of the ViewElement, we can see the element to create, modify, and delet Elm-style messages. After a new message is created, the system automatically creates the case for the message in the Elm-style update function. The user can then define the update logic using JavaScript.</p>"},{"location":"getting-started/#generated-applications","title":"Generated applications","text":"<p>The applications that the system generates follow the Elm-architecture, consisting of:</p> <ol> <li>Model - Application state</li> <li>Messages - User actions</li> <li>Update - State modification logic</li> <li>View - UI rendering</li> </ol> <p>Below we can see an example of the code generated by the system based on the interaction with the UI. The functionality of the application is handled by the following loop:</p> <ol> <li>User interaction triggers dispatch</li> <li>Message passed to update</li> <li>Model modified based on message</li> <li>View re-rendered with new model</li> <li>Repeat</li> </ol> <pre><code>const Msg = {\n    MsgExample : \"MsgExample\",\n };\n\nconst model = {\n    value : 0\n };\n\nconst update = (msg, event, model ) =&gt; {\n    switch (msg) {\n        case Msg.MsgExample :\n            return { ... model };\n        default :\n            return model ;\n    }\n};\nconst view = (model , dispatch ) =&gt; `\n &lt;div &gt;\n &lt;label&gt;${model.value }&lt;/label&gt;\n &lt;/div&gt;`;\n\n\nfunction startApplication ( initialModel, updateFunction, viewFunction) {\n    let currentModel = initialModel ;\n    const render = () =&gt; {\n    const root = document.getElementById (\"app\");\n    root.innerHTML = viewFunction ( currentModel, dispatch );\n    };\n\n    window.dispatch = (msg , event ) =&gt; {\n        currentModel = updateFunction (msg, event, currentModel );\n        render ();\n    };\n    render ();\n}\n\nstartApplication (model, update, view);\n</code></pre>"},{"location":"dev-guide/architecture/","title":"Architecture","text":"<p>InterfaceSmith follows a nested Elmish architecture approach with two main modules:</p> <ol> <li>Core Logic Module</li> <li>Editor Module</li> </ol>"},{"location":"dev-guide/architecture/#main-application-architecture","title":"Main Application Architecture","text":"<p>The main application is implemented as an Elmish application responsible for general functionality like Page management. Each Page is managed by its own Elmish PageEditor sub-application.</p>"},{"location":"dev-guide/architecture/#main-application-state","title":"Main Application State","text":"<pre><code>type Model = {\n    Pages: Map&lt;Guid, PageEditorModel&gt;\n    PageOrder: Guid list\n    ActivePageId: Guid option\n    IsSidebarOpen: bool\n}\n</code></pre>"},{"location":"dev-guide/architecture/#main-application-messages","title":"Main Application Messages","text":"<pre><code>type Msg =\n    | CreatePage\n    | UpdatePage of PageEditorModel\n    | DeletePage of Guid\n    | ToggleSidebar\n    | OpenPage of Guid\n    | PageEditorMsg of Guid * PageEditorMsg\n</code></pre>"},{"location":"dev-guide/architecture/#pageeditor-sub-application","title":"PageEditor Sub-Application","text":"<p>The PageEditor provides modification functionality for individual Pages with:</p> <ul> <li>Local state (PageEditorModel)</li> <li>Update logic (pageEditorUpdate)</li> <li>View components (PageEditorView)</li> </ul>"},{"location":"dev-guide/architecture/#pageeditor-state","title":"PageEditor State","text":"<pre><code>type PageEditorModel = {\n    PageData: Page\n    FileUploadError: bool\n    ViewportPosition: Position\n    Scale: float\n    Elements: Element list\n    DraggingElementId: int option\n    IsPanning: bool\n    LastMousePosition: Position option\n    IsPreviewOpen: bool\n    ContextMenuVisible: bool\n    ContextMenuPosition: Position option\n}\n</code></pre>"},{"location":"dev-guide/architecture/#module-structure","title":"Module Structure","text":""},{"location":"dev-guide/architecture/#core-logic-module","title":"Core Logic Module","text":"<p>Contains core domain logic and operations:</p> <ul> <li> <p>Types/</p> <ul> <li><code>RenderingTypes.fs</code> - Core domain types</li> </ul> </li> <li> <p>Operations/</p> <ul> <li><code>RenderingCode.fs</code> - AST operations</li> <li><code>DataRecognition.fs</code> - JSON to UI mapping</li> <li><code>CodeGeneration.fs</code> - Code generation</li> </ul> </li> </ul>"},{"location":"dev-guide/architecture/#editor-module","title":"Editor Module","text":"<p>Contains UI implementation:</p> <ul> <li> <p>Types/</p> <ul> <li><code>EditorDomain.fs</code> - Main app types</li> <li><code>PageEditorDomain.fs</code> - PageEditor types</li> </ul> </li> <li> <p>Utilities/</p> <ul> <li>Icons</li> <li>File upload</li> <li>JSON parsing</li> <li>JavaScript editor</li> </ul> </li> <li> <p>Components/</p> <ul> <li><code>ElementComponents.fs</code> - Canvas elements</li> <li><code>OptionsComponents.fs</code> - Context menus</li> <li><code>EditorComponents.fs</code> - Editor UI</li> <li><code>PageEditorComponents.fs</code> - PageEditor implementation</li> </ul> </li> <li> <p>CustomRendering/</p> <ul> <li>Preview rendering</li> <li>Modification menus</li> <li>Canvas elements</li> </ul> </li> </ul>"},{"location":"dev-guide/architecture/#key-design-principles","title":"Key Design Principles","text":"<ol> <li>Separation of concerns between main app and PageEditors</li> <li>Domain types separated from operations</li> <li>Core logic independent from UI implementation</li> <li>Modular component-based UI architecture</li> <li>Nested elemish application structure</li> </ol>"},{"location":"dev-guide/core-logic/","title":"Core Logic","text":"<p>The core logic module implements data-driven UI creation through a hole-based approach. This document describes the key concepts and implementation.</p>"},{"location":"dev-guide/core-logic/#hole-based-ui-creation","title":"Hole-Based UI Creation","text":"<p>The system enables incremental UI creation based on concrete data using placeholder \"holes\":</p> <ol> <li>System analyzes JSON input data</li> <li>Creates UI skeleton with hole placeholders</li> <li>Users gradually fill holes with concrete UI elements</li> <li>Structure matches original data hierarchy</li> </ol>"},{"location":"dev-guide/core-logic/#hole-type-definition","title":"Hole Type Definition","text":"<pre><code>type FieldHole =\n    | Named of string  // Holes for specific data fields\n    | UnNamed         // Holes for null values\n</code></pre>"},{"location":"dev-guide/core-logic/#domain-model","title":"Domain model","text":""},{"location":"dev-guide/core-logic/#renderingcode-ast","title":"RenderingCode AST","text":"<p>The main type for representing UI elements is RenderingCode:</p> <pre><code>type RenderingCode =\n    | HtmlElement of tag: Tag * attrs: Attributes * innerValue: InnerValue * eventHandlers: (string * EventHandler) list\n    | HtmlList of listType: ListType * attrs: Attributes * itemCodes: RenderingCode list * eventHandlers: (string * EventHandler) list\n    | HtmlObject of objectType: ObjType * attrs: Attributes * keyOrdering: string list * codes: Map&lt;string, RenderingCode&gt; * eventHandlers: (string * EventHandler) list\n    | Hole of FieldHole\n</code></pre>"},{"location":"dev-guide/core-logic/#json-mapping","title":"JSON mapping","text":"<p>The system maps JSON types to RenderingCode:</p> <ul> <li>JObject \u2192 HtmlObject (Unordered collections)</li> <li>JArray \u2192 HtmlList (Ordered, same-type collections)</li> <li>Primitives \u2192 HtmlElement</li> <li>JNull \u2192 Hole UnNamed</li> </ul>"},{"location":"dev-guide/core-logic/#core-operations","title":"Core operations","text":""},{"location":"dev-guide/core-logic/#path-based-traversal","title":"Path-Based Traversal","text":"<p>Operations use integer paths to locate elements in the ASTs:</p> <pre><code>// Example path: [1,0] points to first item in second list\nHtmlObject(Div)                     // Path: []\n\u251c\u2500\u2500 \"key1\" -&gt; HtmlElement(div)     // Path: [0]\n\u2514\u2500\u2500 \"key2\" -&gt; HtmlList             // Path: [1]\n     \u251c\u2500\u2500 HtmlElement(Li, \"Item 1\") // Path: [1,0]\n     \u2514\u2500\u2500 HtmlElement(Li, \"Item 2\") // Path: [1,1]\n</code></pre>"},{"location":"dev-guide/core-logic/#key-operations","title":"Key Operations","text":"<ol> <li>Replace: Replace element at path with new element</li> <li>Delete: Replace element with Hole</li> <li>Recognize: Map JSON to initial RenderingCode</li> <li>Traverse: Walk both ASTs simultaneously</li> </ol>"},{"location":"dev-guide/core-logic/#creation-process","title":"Creation Process","text":"<ol> <li>System visits JSON node</li> <li>Creates Hole placeholder</li> <li>User triggers replacement</li> <li>System creates new element</li> <li>Element integrated into AST</li> <li>Preview updates automatically</li> </ol>"},{"location":"dev-guide/getting-started/","title":"Developer Getting Started Guide","text":""},{"location":"dev-guide/getting-started/#development-environment-setup","title":"Development Environment Setup","text":""},{"location":"dev-guide/getting-started/#prerequisites","title":"Prerequisites","text":"<ol> <li>Nix package manager with flakes enabled</li> <li>Docker (optional - for container builds)</li> </ol>"},{"location":"dev-guide/getting-started/#setting-up-dev-environment","title":"Setting Up Dev Environment","text":"<ol> <li> <p>Clone the project repository:     <code>git clone https://github.com/JerrySvarc/InterfaceSmith.git     &amp;&amp; cd InterfaceSmith</code></p> </li> <li> <p>Enter development shell using flake:     <code>nix develop</code></p> <p>It starts the nix development shell and provides:</p> <ul> <li>.NET SDK 8</li> <li>Node.js 20</li> <li>Python with mkdocs</li> <li>Other dev dependencies</li> </ul> </li> </ol>"},{"location":"dev-guide/getting-started/#building-the-project","title":"Building the Project","text":"<p>The build system is implemented in Build.fs using FAKE. Key targets include:</p> <ul> <li>Bundle - Creates production build of the editor</li> <li>Run - Starts a development server and the documentation server.</li> <li>RunTests - Runs test suite.</li> <li>BuildDocs - Builds the documentation</li> <li>Format - Formats code using Fantomas</li> </ul>"},{"location":"dev-guide/getting-started/#development-workflow","title":"Development Workflow","text":"<p>After cloning the project's repository and entering the nix shell, ensure to do the following before the first compilation attempt:</p> <ol> <li> <p>Restore .NET tools:</p> <p><code>dotnet tool restore</code></p> </li> <li> <p>Restore Paket dependencies:</p> <p><code>dotnet paket restore</code></p> </li> </ol> <p>Now to start the development server, enter the following command:</p> <pre><code>dotnet run\n</code></pre> <p>It does the following:</p> <ul> <li>Starts Fable dev server on <code>http//localhost:8080</code></li> <li>Starts documentation server on <code>http//localhost:8082</code></li> <li>Watches for changes and hot reload</li> </ul>"},{"location":"dev-guide/getting-started/#running-tests","title":"Running Tests","text":"<p>Tests are implemented in the tests project using Fable.Mocha. To run the tests, input the following command in the nix shell at the root of the project:</p> <pre><code>dotnet run RunTests\n</code></pre>"},{"location":"dev-guide/getting-started/#building-documentation","title":"Building Documentation","text":"<p>Documentation is built using MkDocs with Material theme. Build with:</p> <pre><code>dotnet run BuildDocs\n</code></pre> <p>The documentation source is in Documentation/docs/ and configuration in Documentation/mkdocs.yml.</p>"},{"location":"dev-guide/getting-started/#project-structure","title":"Project Structure","text":"<p>The project structure consists of different files and folders. The following project elements are the most important:</p> <ul> <li>src/ - Main application code<ul> <li>CoreLogic/ - Core domain logic</li> <li>Editor/ - UI components and editor functionality</li> </ul> </li> <li>tests - Test projects</li> <li>Documentation - Documentation source</li> <li>Build.fs - Build script</li> <li>flake.nix - Development environment definition</li> </ul>"},{"location":"user-guide/custom-functionality/","title":"Implementing custom functionality","text":"<p>To implement custom functionality, the system provides two ways of implementing custom behavior:</p> <ol> <li>Custom functions</li> <li>Elm-style messages and update functions</li> </ol>"},{"location":"user-guide/custom-functionality/#messages-and-update-functions","title":"Messages and Update Functions","text":""},{"location":"user-guide/custom-functionality/#creating-new-messages","title":"Creating New Messages","text":"<ol> <li>Locate the Messages element in your canvas</li> <li>Click the \"New Message\" button to create a message</li> <li>The system will automatically:</li> <li>Create a new message with default name <code>NewMessageX</code></li> <li>Add corresponding case to the update function with default implementation</li> <li>Add the message to available event handlers</li> </ol>"},{"location":"user-guide/custom-functionality/#modifying-update-function","title":"Modifying Update Function","text":"<p>For each message, you can modify how it updates the model:</p> <pre><code>// Example update function for a message\nreturn {\n    ...model,            // the existing model\n    Count: model.Count + 1,  // Update specific fields\n};\n</code></pre> <p>The update function receives:</p> <ul> <li>model: Current application state</li> <li>event: Browser event that triggered the message</li> <li>msg: The message type that was dispatched</li> </ul>"},{"location":"user-guide/custom-functionality/#attaching-messages-to-elements","title":"Attaching Messages to Elements","text":"<ol> <li>Select an element in the ViewElement canvas</li> <li>Open the Event Handlers menu</li> <li>Choose an event type (e.g. \"onClick\")</li> <li>Select your message from the handler dropdown</li> <li>Click \"Add Handler\" to attach</li> </ol> <p>Example element with message handler:</p>"},{"location":"user-guide/custom-functionality/#preview-changes","title":"Preview Changes","text":"<p>You can test your custom functionality by:</p> <ol> <li>Clicking \"Run application\" in the ViewElement toolbar</li> <li>Interacting with the elements in preview mode</li> <li>Observing model updates in real-time</li> </ol> <p>The system will execute your update functions and re-render the UI automatically when messages are dispatched.</p>"},{"location":"user-guide/data-preparation/","title":"Input Data Guide","text":""},{"location":"user-guide/data-preparation/#overview","title":"Overview","text":"<p>InterfaceSmith generates UI elements based on JSON data structures. We will now describe how the data provided to the application can be used to create the new UI elements.</p> <p>As you model/acquire the data you wish to use, make sure the data has a valid structure. Pay attention to Array types, as the system assumes that Arrays contain data of the same type and structure. This is a prerequisite requirement for the system to function correctly.</p>"},{"location":"user-guide/data-preparation/#json-to-ui-mapping","title":"JSON to UI Mapping","text":""},{"location":"user-guide/data-preparation/#primitive-types","title":"Primitive Types","text":"<p>The table below shows the different JSON primitives and their corresponding example UI elements you can create based on this data. However, the examples are really just examples, and you can modify them. The system automatically creates the elements based on the data, and you can specify the tag, attributes, and event handlers using the provided context menus to create the particular elements you want.</p> JSON Type Example UI Element Example String Text Input <code>\"name\": \"John\"</code> Number Label <code>\"age\": 25</code> Boolean Checkbox <code>\"active\": true</code> Null Empty element <code>\"optional\": null</code>"},{"location":"user-guide/data-preparation/#collections","title":"Collections","text":"JSON Type Example UI Element Example Object Article <code>{\"user\": {...}}</code> Array Ordered List <code>\"items\": [...]</code> <p>The collections are types that contain other data as children. The Object is an unordered collection containing different types of data; we assume each type can have a different structure. However, we assume that the Array is ordered and consists of elements of the same type and structure.</p>"},{"location":"user-guide/data-preparation/#example-input-data","title":"Example Input Data","text":"<p>Below we can see an example of data to create a simple TO-DO list application's UI elements.</p> <pre><code>{\n    \"InputField\": \"\",\n    \"AddTodo\": \"Add todo\",\n    \"Todos\": [\n        {\n            \"text\": \"Complete project proposal\",\n            \"completed\": false\n        }\n    ],\n    \"Others\": {\n        \"CompletedCount\": 0,\n        \"AllDoneButton\": \"All done\"\n    }\n}\n</code></pre> <p>Fig: Example JSON data</p>"},{"location":"user-guide/element-modification/","title":"UI element modification","text":"<p>The created UI elements are previewed in the canvas ViewElement. This is also where the low-code modification menus are displayed right next to the elements themselves. We will now describe the modification menus for each type if created UI element.</p>"},{"location":"user-guide/element-modification/#attributes","title":"Attributes","text":"<p>We will first describe the attribute menu, as it is common to all the UI elements. You can define a new attribute by typing its name in the \"Attribute Name\" input box and then clicking the \"Add New Attribute\" button.</p> <p>Under it you can see the created attributes. You can change the key of the attribute by double-clicking it, or change its value. The value types are:</p> <ol> <li>Data - value is set to the value of the corresponding JSON field</li> <li>Constant - user defined value</li> <li>Empty - no value</li> </ol> <p></p>"},{"location":"user-guide/element-modification/#event-handlers","title":"Event Handlers","text":"<p>The attribute menu is common to all the UI elements. To add a new handler, you select an event from the selection on the left and then select the corresponding handler on the right. The handler is either a user defined custom function or a message.</p> <p>You can see the created event handlers below this menu and can delete the attached event handlers.</p> <p></p>"},{"location":"user-guide/element-modification/#hole","title":"Hole","text":"<p>You can use the menu you see below to replace the placeholder hole with a new element created based on the underlying data. </p>"},{"location":"user-guide/element-modification/#htmlelement","title":"HtmlElement","text":"<p>The HtmlElement is created based on a primitive JSON value. You can change its tag using the provided selection menu on the left. You can also change its value via the selection menu on the right:</p> <ol> <li>Data - value is set to the value of the corresponding JSON field</li> <li>Constant - user defined value</li> <li>Empty - no value</li> </ol> <p></p>"},{"location":"user-guide/element-modification/#htmllist","title":"HtmlList","text":"<p>The HtmlList is created based on the Array JSON type. You can change it to be either ordered or unordered, and also use the event handler and attribute menus.</p> <p></p>"},{"location":"user-guide/element-modification/#htmlobject","title":"HtmlObject","text":"<p>The HtmlList is created based on the Object JSON type. You can change its type using the select menu, and also use the event handler and attribute menus. As we assume the Object is unordered, you can also change the rendering order of its elements using the \"Key ordering\" menu by clicking the arrows and moving the corresponding keys up and down.</p> <p></p>"}]}